# 7月30日

# 模板匹配

## 概念

* 模板匹配是在图像中找到相似于模板图像(patch)的区域
* 虽然 patch 必须是个矩形，但是并不一定矩形的全部区域都是相关的。这种情况下我们可以使用掩码来孤立出我们用来作匹配的部分区域
---
## 原理

* 我们需要两个主要的组件
      1. 源图像(I): 我们想要在源图像中找到匹配模板图像的区域
      2. 模板图像(T): patch 将会与模板图像做比较
    我们的目标是探测到最高程度匹配的区域
    ![](Template_Matching_Template_Theory_Summary.jpg)

* 为了标识出匹配区域，我们需要将模板图像在源图像上通过滑动的方式进行对比
  ![](Template_Matching_Template_Theory_Sliding.jpg)

* 滑动的含义是我们每次移动一个像，在每个位置我们计算一个度量值用来衡量此处与模板图像匹配的位置
* 在每个 T 覆盖 I 的位置我们将计算的度量结果存储在结果矩阵 **R** 中，**R** 每个(x, y)包含测量结果
  ![](Template_Matching_Template_Theory_Result.jpg)
  上面是结果矩阵，结果类型为 `TM_CCORR_NORMED`。最亮的地方表示最高的匹配度，我们可以看到，画有红色圆圈的地方表示最亮的地方，所以这个位置(表示模板图像的左上角)被认为是匹配的地方

* 在实践中，我们使用 `cv::minMaxLoc` 来在结果矩阵中定位最大值(或者最小值，取决于匹配的方法)

## 掩模的工作原理

* 如果匹配需要掩模，需要至少三个组件

    1. Source image(I):
    2. Template image(T):
    3. Mask Image(M):

* 目前只有两种实现方法接受掩码: `CV_TM_SQDIFF` 和 `CV_TM_NORMED`
* 掩码必须和模板图像有相同的维数
* 掩码的深度应该为 `CV_8U` 和 `CV_32F` 并且和模板图像相同的通道数，在`CV_8U`情况下，掩模的值会二极化对待，零值和非零值。在`CV_32F`情况下，取值应该在[0...1]之间，模板图像中的像素将会与掩模相乘。因为源图像的类型为`CV_8UC3`，掩模同样也以彩色图像读取
